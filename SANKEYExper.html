<!DOCTYPE html>
<meta charset="utf-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="../../favicon.ico">

    <title>actor network tool</title>

    <!-- Bootstrap core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">


    <!-- Custom styles for this template -->
    <link href="css/navbar-fixed-top.css" rel="stylesheet">

    <link rel="stylesheet" type="text/css" href="css/MyFontsWebfontsKit.css">
<style>

.node rect {
  cursor: move;
  shape-rendering: crispEdges;
}

.node text {
  color: "#333333";
  
}

.link,
.adding,
.loss,
.loop {
  fill: none;
  stroke-opacity: .9;
}


</style>
  <body>

    <!-- Fixed navbar -->
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <img src="img/logoANT80-01.png" alt="Actor Network Logo" style="float:left;vertical-align:bottom;width:48px;height:48px;">
          <a class="navbar-brand" href="#" style="padding-left:32px;fill:#515151" >Actor Network Tool</a>
                  </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav navbar-right">
            <li class="active"><a href="#intro">About</a></li>
            <li><a href="#features">Network Articulations</a></li>
            <li><a href="#form">Data Formatting</a></li>
            <!--<li><a href="#quant">Quantitative Demo</a></li>
            <li><a href="#qual">Qualitative Demo</a></li>

            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Generators <span class="caret"></span></a>
              <ul class="dropdown-menu">
              <li><a href="#">Web Generator</a></li>
              <li><a href="#">Omeka Plug-In</a></li>
              <li><a href="#">Wordpress Plug-In</a></li>
              </ul>
            </li>

            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="#">PDF Tutorials</a></li>
                <li><a href="#">Vimeo Tutorials</a></li>
                <li><a href="#">Github Wiki</a></li>
                <li><a href="#">Github Repository</a></li>
                </ul>
            </li>

            <li><a href="#contact">Contact</a></li>-->
            
          </ul>
          <!--<ul class="nav navbar-nav navbar-right">
            <li><a href="../navbar/">Default</a></li>
            <li><a href="../navbar-static-top/">Static top</a></li>
            <li class="active"><a href="./">Fixed top <span class="sr-only">(current)</span></a></li>
          </ul>-->
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
      <div class="jumbotron" id="intro">
        <h2>actor network tool</h2>
        <h4>Embedded Connections, inflections, & feedback</h4><br>
       <p>This example is a quick exercise to illustrate how the default, static and fixed to top navbar work. It includes the responsive CSS and HTML, so it also adapts to your viewport and device.</p>
        <p>To see the difference between static and fixed top navbars, just scroll.</p>
      </div>
      <div id="features">
        <br>
        <h2 style="text-align:center; padding-top:20px">articulation options</h2>
        <p style="text-align:center;line-height:0px">click for demos: connection types and styling, interactive and interpretive features</p><br>
        <span class= "col-md-2">
            <h4> nodes </h4>
            <form>
              <input type="radio" name="nOpt" value="defaultNodes" onchange="opt=radioC()" checked> default nodes<br>
              <input type="radio" name="nOpt" value="expandedArrows" onchange="opt=radioC()" > expanded arrows<br> 
              <input type="radio" name="nOpt" value="bracketIcons" onchange="opt=radioC()" > bracket icons<br>
              <input type="radio" name="nOpt" value="background" onchange="opt=radioC()"> background underlays
            </form>      
        </span>
        <span class= "col-md-2">
            <h4> links </h4>
            <form>
              <input type="radio" name="lOpt" value="defaultLinks" onchange="opt=radioC()" checked> default links<br>
              <input type="radio" name="lOpt" value="addLoss" onchange="opt=radioC()"> add/loss links<br>
              <input type="radio" name="lOpt" value="feedback" onchange="opt=radioC()"> feedback links<br> 
              <input type="radio" name="lOpt" value="percent" onchange="opt=radioC()"> percent links
            </form> 
        </span>
        <span class= "col-md-2">
            <h4> color & text</h4>
            <form>
              <input type="radio" name="cOpt" value="defaultColor" onchange="opt=radioC()" checked> black & white<br>
              <input type="radio" name="cOpt" value="greysContrast" onchange="opt=radioC()"> greys & contrast<br>
              <input type="radio" name="cOpt" value="colorGradients" onchange="opt=radioC()"> color gradients<br> 
              <input type="radio" name="cOpt" value="googleFonts" onchange="opt=radioC()"> google fonts
            </form> 
        </span>
        <span class= "col-md-2">
            <h4> overlays </h4>
            <form>
              <input type="radio" name="oOpt" value="defaultTooltips" onchange="opt=radioC()" checked> tooltips variations <br>
              <input type="radio" name="oOpt" value="timeS" onchange="opt=radioC()"> time series<br>
              <input type="radio" name="oOpt" value="typeS" onchange="opt=radioC()"> type series<br> 
              <input type="radio" name="oOpt" value="background" onchange="opt=radioC()"> tabbed series
            </form>  
        </span>
        <span class= "col-md-2">
            <h4> stories </h4>
            <form>
              <input type="radio" name="sOpt" value="database" onchange="opt=radioC()" checked> database uploads<br>
              <input type="radio" name="sOpt" value="iconNav" onchange="opt=radioC()"> icon navigation<br>
              <input type="radio" name="sOpt" value="linkNav" onchange="opt=radioC()" > linked narratives<br> 
              <input type="radio" name="sOpt" value="layoutNav" onchange="opt=radioC()" > layout options
            </form>  
        </span>
        <span class= "col-md-2">
            <h4> (embeds)</h4>
            <form>
              <input type="radio" name="eOpt" value="print/save" id="eOpt" checked> print/save<br>
              <input type="radio" name="eOpt" value="htmlEmbeds" id="eOptA1"> html embeds<br>
              <input type="radio" name="eOpt" value="webGen" id="eOptA2" > web generator<br> 
              <input type="radio" name="eOpt" value="CMS" id="eOptB" > cms plug-ins
            </form>  
        </span>
      </div>
      <div id="notes" style="padding-top:120px">
        <br>
      <form> 
      <p id="chartSize" style="text-transform: capitalize"> Drag Nodes to reposition, Hoover/Click on Titles for interaction </p>
      <p style="font-size:12px; text-transform: capitalize; line-height:4px"> Solid strokes = <em> basic progression from source to target;</em> fading lines = <em> additions or externalities typically considered outside the main system;</em> dashed strokes = <em> feedback from later stages in process </em></p>
      <p style="font-size:12px; opacity: .5; text-transform: capitalize">Note: Demonstration below doesn't provide full range of choices, but rather the types under development; alternate data structures link to different tables, see <a href:"/#form"> Data Formatting </a> for details </p>
      </div>
<div id="chart"></div>
      <div id="extras">
      </div>
      <div id="form">
      </div> 
    </div> <!-- /container -->


<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="js/sankeyAlt.js"></script>
<script src="js/colorbrewer.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="../../assets/js/vendor/jquery.min.js"><\/script>')</script>
<script src="js/bootstrap.min.js"></script>
<script src="https://d3js.org/d3-color.v1.min.js"></script>
<script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
    

<script>

//--------------------------- radio check-------------------------------------------
      var radioOption={};
      var opt={};


      function radioC(){
          var opts=['nOpt', 'lOpt', 'cOpt', 'oOpt', 'sOpt', 'eOpt'];
          var optsKey=['n', 'l','c','o', 's', 'e'];

        for (var i = 0; i < opts.length; i++) {
          var eleN = document.getElementsByName(opts[i]);
          var eleKey=optsKey[i];

          for (var j=0; j<eleN.length; j++){
            if (eleN[j].checked) {
                radioOption[eleKey]=eleN[j].value;
            }
          };
        };

        //opt=radioOption;
        console.log(radioOption); // to get a sense of updates
        return radioOption;
      };
     
opt=radioC();





//----------------------------------------------------------------------------------
	
var units = "Units";

var margin = {top: 20, right: 60, bottom: 60, left: 60},
    width = 1100;

var height = 400 - margin.top - margin.bottom; // should make this very adaptable for legibility

//color gradient options need to be better... create 3-4 nice gradients
//purple to orange
//spring green through navy
//hot red through mustard
//red through purple
//etc. 


var purorange=["#800080", "#8b0078", "#95006c", "#a0005e", "#aa004d", "#b50039", "#c00022", "#ca0008", "#d51500", "#df3500", "#ea5700", "#f47d00", "#ffa500"];
var greys=[ "#333333", "#424242", "#515151", "#616161", "#707070", "#7f7f7f", "#8e8e8e", "#9e9e9e", "#adadad", "#bcbcbc", "#cbcbcb", "#dbdbdb", "#eaeaea"]; 
/*var color = d3.scale.linear()
    .range(["#800080", "#ffa500"])
    .interpolate(d3.interpolateHcl);*/


  if (opt.c==="colorGradients"){
      var formatNumber = d3.format(",.0f"),    // zero decimal places
      format = function(d) { return formatNumber(d) + " " + units; },
          color = d3.scale.ordinal()
          .domain(d3.range(7))
          //.range(custom.purorange);
          .range(colorbrewer.YlGnBu[9])
      } else if (opt.c==="greysContrast"){
      var formatNumber = d3.format(",.0f"),    // zero decimal places
      format = function(d) { return formatNumber(d) + " " + units; },
          color = d3.scale.ordinal()
          .domain(d3.range(7))
          .range(greys);

      } else {
      var formatNumber = d3.format(",.0f"),    // zero decimal places
      format = function(d) { return formatNumber(d) + " " + units; },
          color = d3.scale.ordinal()
          .domain([.65, .75])
          .range(["#333","#333"]);
      };




// append the svg canvas to the page
var svg = d3.select("#chart").append("svg")
    .attr("width", width)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", 
          "translate(" + 0 + "," + margin.top + ")");

    //var groupnodes = svg.append("g");
    var grouplines2 = svg.append("g");
    var grouplines=svg.append("g");
    var groupnodes = svg.append("g");
    var groupicons = svg.append("g"); // options for visuals

// Set the sankey diagram properties
var sankey = d3.sankey()
    .nodeWidth(45)
    .nodePadding(100)
    .size([width-48, height]);

var path = sankey.link();

// load the data (using the timelyportfolio csv method)
//d3.csv("data/demoMB.csv", function(error, data) {
d3.csv("data/sankey.csv", function(error, data) {

  //set up graph in same style as original example but empty
  graph = {"nodes" : [], "links" : [], "adding":[], "loss":[], "loop":[]};// expanded as needed for annotations

    data.forEach(function (d) {

      if (d.type===""){
        graph.nodes.push({ "name": d.source });
        graph.nodes.push({ "name": d.target });

        graph.links.push({ "source": d.source,
                         "target": d.target,
                         "type": d.type,
                         "value": +d.value }); 

      } 
      else if (d.type==="adding"){ // this is presuming no internal value addition, yet..
        graph.nodes.push({ "name": d.target });

        graph.adding.push({"name": d.source,
                        "source":d.source,
                        "target": d.target,
                         "type": d.type,
                         "value": +d.value});

      } else if (d.type==="loss"){
        graph.nodes.push({ "name": d.source });

        graph.loss.push({"name": d.target,
                        "source":d.source,
                        "target": d.target,
                         "type": d.type,
                         "value": +d.value});

      } else if (d.type==="loop"){
        graph.nodes.push({ "name": d.source });
        graph.nodes.push({ "name": d.target });

        graph.loop.push({"name": d.source,
                        "source": d.source,
                        "target": d.target,
                         "type": d.type,
                         "value": +d.value});
      };
      });

    console.log(graph);

     // return only the distinct / unique nodes
     graph.nodes = d3.keys(d3.nest()
      //graph.nodes = d3.nest()
       .key(function (d) { return d.name; })
       .map(graph.nodes));

    console.log(graph.nodes);

    // highlight gradients... then link, etc.

    var gradientHA = svg.append("defs")
          .append("linearGradient")
          .attr("id", "gradHA");

          gradientHA.append("stop")
                  .attr("offset", "0%")
                  .attr("stop-color", "#ffffff")
                  .attr("stop-opacity", 0);

          gradientHA.append("stop")
                  .attr("offset", "50%")
                  .attr("stop-color", "#ff006a")
                  .attr("stop-opacity", .25);        

          gradientHA.append("stop")
                  .attr("offset", "100%")
                  .attr("stop-color", "#ff006a")// pink
                  .attr("stop-opacity", 1);

    var gradientLA = svg.append("defs")
          .append("linearGradient")
          .attr("id", "gradLA");

          gradientLA.append("stop")
                  .attr("offset", "0%")
                  .attr("stop-color", "#ff006a")
                  .attr("stop-opacity", 1);

          gradientLA.append("stop")
                  .attr("offset", "50%")
                  .attr("stop-color", "#ff006a")
                  .attr("stop-opacity", .25);        

          gradientLA.append("stop")
                  .attr("offset", "100%")
                  .attr("stop-color", "#ffffff")// pink
                  .attr("stop-opacity", 0);


    var gradientHAG = svg.append("defs")
          .append("linearGradient")
          .attr("id", "gradHAG");

          gradientHAG.append("stop")
                  .attr("offset", "0%")
                  .attr("stop-color", "#ffffff")
                  .attr("stop-opacity", 0);

          gradientHAG.append("stop")
                  .attr("offset", "50%")
                  .attr("stop-color", "#333333")
                  .attr("stop-opacity", .25);        

          gradientHAG.append("stop")
                  .attr("offset", "100%")
                  .attr("stop-color", "#333333")// grey
                  .attr("stop-opacity", 1);

    var gradientLAG = svg.append("defs")
          .append("linearGradient")
          .attr("id", "gradLAG");

          gradientLAG.append("stop")
                  .attr("offset", "0%")
                  .attr("stop-color", "#333333")
                  .attr("stop-opacity", 1);

          gradientLAG.append("stop")
                  .attr("offset", "50%")
                  .attr("stop-color", "#333333")
                  .attr("stop-opacity", .25);        

          gradientLAG.append("stop")
                  .attr("offset", "100%")
                  .attr("stop-color", "#ffffff")// pink
                  .attr("stop-opacity", 0);

     // loop through each link replacing the text with its index from node
     graph.links.forEach(function (d, i) {
       graph.links[i].source = graph.nodes.indexOf(graph.links[i].source);
       graph.links[i].target = graph.nodes.indexOf(graph.links[i].target);
       graph.links[i].scolor = color(graph.nodes[graph.links[i].source].replace(/ .*/, "")); // color( name.replace....)
       graph.links[i].tcolor = color(graph.nodes[graph.links[i].target].replace(/ .*/, ""));

        var gradient = svg.append("defs")
          .append("linearGradient")
          .attr("id", "grad"+i);


          //gradient.attr("x1", graph.links[i].source.x)
              //.attr("y1", graph.links[i].source.y)
              //.attr("x2", graph.links[i].target.x)
              //.attr("y2", graph.links[i].target.y);

          gradient.append("stop")
                  .attr("offset", "0%")
                  .attr("stop-color", graph.links[i].scolor)
                  .attr("stop-opacity", 1);

          gradient.append("stop")
                  .attr("offset", "100%")
                  .attr("stop-color", graph.links[i].tcolor)
                  .attr("stop-opacity", 1);
       //graph.links[i].color = d3.interpolateRgb(graph.links[i].scolor, graph.links[i].tcolor);
     });

         // loop through each link replacing the text with its index from node
     graph.adding.forEach(function (d, i) {
       graph.adding[i].source = graph.nodes.indexOf(graph.adding[i].source); //should give a -1 index ... if get -1, search other links and take their x half way between areas
       graph.adding[i].target = graph.nodes.indexOf(graph.adding[i].target);
       graph.adding[i].scolor = "#ffffff"; // color( name.replace....)
       graph.adding[i].tcolor = color(graph.nodes[graph.adding[i].target].replace(/ .*/, ""));

        var gradient = svg.append("defs")
          .append("linearGradient")
          .attr("id", "gradA"+i);

          gradient.append("stop")
                  .attr("offset", "0%")
                  .attr("stop-color", graph.adding[i].scolor)
                  .attr("stop-opacity", 0);

          gradient.append("stop")
                  .attr("offset", "50%")
                  .attr("stop-color", graph.adding[i].scolor)
                  .attr("stop-opacity", .25);        

          gradient.append("stop")
                  .attr("offset", "100%")
                  .attr("stop-color", graph.adding[i].tcolor)
                  .attr("stop-opacity", 1);

       //graph.links[i].color = d3.interpolateRgb(graph.links[i].scolor, graph.links[i].tcolor);
     });

     graph.loss.forEach(function (d, i) {
       graph.loss[i].source = graph.nodes.indexOf(graph.loss[i].source); 
       graph.loss[i].target = graph.nodes.indexOf(graph.loss[i].target); //should give a -1 index ... if get -1, search other links and take their x half way between areas
       graph.loss[i].tcolor = "#ffffff"; // color( name.replace....)
       graph.loss[i].scolor = color(graph.nodes[graph.loss[i].source].replace(/ .*/, ""));

        var gradient = svg.append("defs")
          .append("linearGradient")
          .attr("id", "gradL"+i);

          gradient.append("stop")
                  .attr("offset", "0%")
                  .attr("stop-color", graph.loss[i].scolor)
                  .attr("stop-opacity", 1);

          gradient.append("stop")
                  .attr("offset", "50%")
                  .attr("stop-color", graph.loss[i].tcolor)
                  .attr("stop-opacity", .25);

          gradient.append("stop")
                  .attr("offset", "100%")
                  .attr("stop-color", graph.loss[i].tcolor)
                  .attr("stop-opacity", 0);
       //graph.links[i].color = d3.interpolateRgb(graph.links[i].scolor, graph.links[i].tcolor);
     });

     graph.loop.forEach(function (d, i) {
       graph.loop[i].source = graph.nodes.indexOf(graph.loop[i].source); 
       graph.loop[i].target = graph.nodes.indexOf(graph.loop[i].target); //should give a -1 index ... if get -1, search other links and take their x half way between areas
       graph.loop[i].tcolor = color(graph.nodes[graph.loop[i].target].replace(/ .*/, ""));// color( name.replace....)
       graph.loop[i].scolor = color(graph.nodes[graph.loop[i].source].replace(/ .*/, ""));
       //graph.loop[i].mcolor = d3.interpolateCubehelix(graph.loop[i].tcolor, graph.loop[i].scolor)(0.5);
       //graph.loop[i].mcolor = interpolator(.5); 

        var gradient = svg.append("defs")
          .append("linearGradient")
          .attr("id", "gradF"+i);

          gradient.append("stop")
                  .attr("offset", "30%")
                  .attr("stop-color", graph.loop[i].tcolor)
                  .attr("stop-opacity", 1);

          gradient.append("stop")
                  .attr("offset", "70%")
                  .attr("stop-color", graph.loop[i].scolor)
                  .attr("stop-opacity", 1);



       //graph.links[i].color = d3.interpolateRgb(graph.links[i].scolor, graph.links[i].tcolor);
     });
    
    // console.log(graph.nodes);
    // console.log(graph.loop);

     //now loop through each nodes to make nodes an array of objects
     // rather than an array of strings
     graph.nodes.forEach(function (d, i) {
       graph.nodes[i] = { "name": d };
       graph.nodes[i].icon=(d.toLowerCase()+".svg"); // icons have been renamed to match node name (easier than table set-up)

     });

console.log(graph.nodes);

  sankey // so just to summing equations here.....graph = {"nodes" : [], "links" : [], "add":[], "loss":[], "loop":[]};
    .nodes(graph.nodes)
    .links(graph.links)
    .adding(graph.adding)
    .loss(graph.loss)
    .loop(graph.loop) // second round of reworking.
    .layout(32);




function addingCurve (){
  var sy=0;
  var n=0;
  var nodeThis='';

    graph.adding.forEach(function(d){
      var nodeC=d.target;
          if (nodeC!==nodeThis){
            nodeThis=nodeC;
            sy=0;
            n=0;
          } else {
            n++;
          };

          //console.log(d);
      var fbV=0;
      graph.loop.forEach(function(feedback){
          if (graph.nodes[feedback.target].name===nodeC.name){
            fbV+=feedback.value;
          };
      });

      var xPos=nodeC.x;
      var yPos=nodeC.y+nodeC.dy-(nodeC.dy/nodeC.value*fbV)-(nodeC.dy/nodeC.value*d.value/2)-sy; 
      sy+=(nodeC.dy/nodeC.value*d.value); //top+depth-half of value
      d.stroke = nodeC.dy/nodeC.value*d.value; 

      var xStart=[0];
      nodeC.targetLinks.forEach(function(targetL, i){
        if ((targetL.source.x+targetL.source.dx)>xStart[0]){
          xStart[0]=(targetL.source.x+targetL.source.dx);
        };
      });

      var xPos0=(xPos-Number(xStart))/2+Number(xStart)-n*50;

      var curvature = .5;

          var x0 = xPos0,
              x01= xPos0-10,
              x1 = xPos,
              xi = d3.interpolateNumber(x0, x1),
              x2 = xi(curvature),
              x3 = xi(1 - curvature),
              y0 = height + margin.top,
              y01= height + margin.top-20,
              y1 = yPos;
           d.path="M" + x0 + "," + y0
                //+ "C" + x0+","+y0
               + "C" + x2 + "," + y01
               + " " + x3 + "," + y1
               + " " + x1 + "," + y1;

      
        
    });
};
addingCurve();

function lossCurve (){
  var sy=0,
      n=0,
      nodeThis=''; // start counters

  graph.loss.forEach(function(d){
          var nodeC=d.source;

          if (nodeC!==nodeThis){
            nodeThis=nodeC;
            sy=0;
            n=0;
          } else {
            n++;
          };

          var xPos=nodeC.x+nodeC.dx;
          var yPos=sy+nodeC.y+(nodeC.dy/nodeC.value*d.value/2);
          sy+=(nodeC.dy/nodeC.value*d.value);
          d.stroke = nodeC.dy/nodeC.value*d.value; //top+depth-half of value

          var xStart=[width];
          nodeC.sourceLinks.forEach(function(targetL, i){
            if ((targetL.target.x)>xPos&(targetL.target.x)<xStart[0]){
              xStart[0]=(targetL.target.x);
            };
          });

          var xPos0=(Number(xStart)-xPos)/2+Number(xPos)+n*50;

          var curvature = .5;

              var x0 = xPos,
                  x1 = xPos0,
                  xi = d3.interpolateNumber(x0, x1),
                  x2 = xi(curvature),
                  x3 = xi(1 - curvature),
                  y0 = yPos,
                  y01= 20,
                  y1 = 0;
               d.path="M" + x0 + "," + y0
                   + "C" + x2 + "," + y0
                   + " " + x3 + "," + y1
                   //+ " " + x3 + "," + y01
                   + " " + x1 + "," + y1;

                  
            
        });
};
lossCurve();

function loopCurve (){
  var ssy=0,
      sn=0,
      strokeSt=0;
      snodeThis=''; // start counters
  var esy=0,
      en=0,
      strokeEn=0;
      enodeThis=''; // end counters

  graph.loop.forEach(function(d){ // rework from here

          var nodeSt=d.source;
          //d.source=graph.nodes[nodeSt];
          var nodeEn=d.target;
          //d.target=graph.nodes[nodeEn];


          if (nodeSt!==snodeThis){
            snodeThis=nodeSt;
            ssy=0;
            sn=0;
            strokeSt=0;
          } else {
            sn++;
          };

          if (nodeEn!==enodeThis){
            enodeThis=nodeEn;
            esy=0;
            en=0;
            strokeEn=0;
          } else {
            en++;
          };


      nodeSt=graph.nodes[nodeSt];
      nodeEn=graph.nodes[nodeEn];
      d.nameEnd=nodeEn.name;

      var xsPos=nodeSt.x+nodeSt.dx; 
      var ysPos=nodeSt.y+nodeSt.dy-(nodeSt.dy/nodeSt.value*d.value/2)-ssy; 
      ssy+=(nodeSt.dy/nodeSt.value*d.value); //top+depth-half of value
      d.stroke = nodeSt.dy/nodeSt.value*d.value;
      var ysPos0 = nodeSt.y+nodeSt.dy+ d.stroke;

      var xePos=nodeEn.x;
      var yePos=nodeEn.y+nodeEn.dy-(nodeEn.dy/nodeEn.value*d.value/2)-esy; 
      esy+=(nodeEn.dy/nodeEn.value*d.value);
      var yePos0 = nodeEn.y+nodeEn.dy+ d.stroke; //top+depth-half of value

      var xsPosAnc1=xsPos+nodeSt.dx;
      if (sn=0){
        var ysPosAnc1=0;
      } else {
        var xsPosAnc2=0;
      };
      var xsPosArm=xsPos-nodeSt.dx/3;


      if ((nodeEn.x + nodeEn.dx*3)>=nodeSt.x 
        //&& (nodeEn.x - nodeEn.dx*4)<nodeSt.x
        ){
        // && nodeSt.y<nodeEn.y){ // top node to bottom

        d.path="M" + xsPos + "," + ysPos
                +"C" + (xsPos+nodeSt.dx*3) + ","+ ysPos
                +" "+ (xePos-nodeEn.dx*3)+","+(yePos)
                +" "+ (xePos)+","+(yePos);
                
      } else {


           d.path="M" + xsPos + "," + ysPos
                +"C" + (xsPos+d.stroke*1.5) + ","+ (ysPos)
                +" "+ (xsPos+d.stroke*1.5)+","+(ysPos0)
                +" "+ xsPos+","+(ysPos0)
                +"L"+(xsPos-nodeSt.dx/3)+","+(ysPos0)
                +"C"+(xsPos-nodeSt.dx*3)+","+(ysPos0)
                +" "+ (xePos+nodeEn.dx*3)+","+(yePos0)
                +" "+ (xePos+nodeEn.dx/3)+","+(yePos0)
                +"L"+xePos+","+(yePos0)
                +"C" + (xePos-d.stroke*1.5) + ","+ (yePos0)
                +" "+ (xePos-d.stroke*1.5)+","+yePos
                +" "+ xePos+","+yePos;
                
      };
          /*  m, move(x0,y0)... then curve at +10, move v-d.stroke*2, then horizontal -node.dx-10, the interpolated(curve), ditto(1-curve), node2.dx and v.y+dy+stoke*2, horizontal dx+10, v+d.stroke*2, horizontal+10... ends

          */

      
        
    });
};
loopCurve();


/* graph.adding[i].target = node number it connects to > so nodes[...]
  find the node links (ie target links)
  compare the lenght of said d.x of origin nodes to target node...grab shortest distance and take the x position of halfway to note... = x0, 
  x1 being the target node d.x... run the link/line generating version on both adds and losses here.

*/

//check options or update options
 if (jQuery.isEmptyObject(opt)|| opt!=radioC()){
    opt=radioC();
 };  

//console.log(opt);
var gFont='';
var gFontp='';

if (opt.c==="googleFonts"){
  $("head").append("<link href='https://fonts.googleapis.com/css?family=Fugaz+One|Josefin+Slab' rel='stylesheet'>");
  gFont="Fugaz One";
  gFontp="Josefin Slab"; 
}

// couple functions for the mouseover/mouseout highlights on LINKS/ADDS/LOSS/LOOPS--------------------------------------------------------

    function highlight(dt){
            //dt=d3.select(this); which is the starting node
            //console.log(dt);

            var col="";
            if ((dt.attr("class")==="link"||dt.attr("class")==="loop") && (opt.c==="greysContrast"|| opt.c==="defaultColor"|| opt.c==="googleFonts")){
                col="#ff006a";
            } else if ((dt.attr("class")==="link"||dt.attr("class")==="loop") && opt.c==="colorGradients"){
                col="#333333";
            } else if (dt.attr("class")==="adding" && (opt.c==="greysContrast"|| opt.c==="defaultColor"|| opt.c==="googleFonts")){
                col="url(#gradHA)";
            } else if (dt.attr("class")==="adding"){
                col="url(#gradHAG)";
            } else if (dt.attr("class")==="loss" && (opt.c==="greysContrast"|| opt.c==="defaultColor"|| opt.c==="googleFonts")){
                col="url(#gradLA)";
            } else if (dt.attr("class")==="loss"){
                col="url(#gradLAG)";
            };

                    if (opt.c==="greysContrast"|| opt.c==="defaultColor"|| opt.c==="googleFonts"){ // when in greyscales or not
                      // if class  link-loop-source, if link-loop-target... stroke for all
                      if (dt.attr("class")==="link"||dt.attr("class")==="loop"|| dt.attr("class")==="loss"){
                        d3.select(dt.attr("sc")).attr("fill", "#ff006a");
                        d3.select(dt.attr("sc")+"Node").attr("fill", "#ff006a");
                        d3.select(dt.attr("sc")+"Node").attr("stroke", "#ff006a");
                        if (d3.select(dt.attr("sc")+"Arrow")){ 
                        d3.select(dt.attr("sc")+"Arrow").attr("fill", "#ff006a");
                        };// arrow heads add if not null
                      };

                      if (dt.attr("class")==="link"||dt.attr("class")==="loop"|| dt.attr("class")==="adding"){ 
                        d3.select(dt.attr("tg")).attr("fill", "#ff006a");
                        d3.select(dt.attr("tg")+"Node").attr("fill", "#ff006a");
                        d3.select(dt.attr("tg")+"Node").attr("stroke", "#ff006a");
                        if (d3.select(dt.attr("tg")+"Arrow")){ 
                          d3.select(dt.attr("tg")+"Arrow").attr("fill", "#ff006a");
                          };
                      };

                      dt.attr("stroke", col);

                  } else { // when in color this is greyscale

                    if (dt.attr("class")==="link"||dt.attr("class")==="loop"|| dt.attr("class")==="loss"){ 
                      d3.select(dt.attr("sc")).attr("fill", "#333333");
                      d3.select(dt.attr("sc")+"Node").attr("fill", "#333333");
                      d3.select(dt.attr("sc")+"Node").attr("stroke", "#333333");
                      if (d3.select(dt.attr("sc")+"Arrow")){ 
                        d3.select(dt.attr("sc")+"Arrow").attr("fill", "#333333");
                        };
                    };
                    if (dt.attr("class")==="link"||dt.attr("class")==="loop"|| dt.attr("class")==="adding"){
                      d3.select(dt.attr("tg")).attr("fill", "#333333");
                      d3.select(dt.attr("tg")+"Node").attr("fill", "#333333");
                      d3.select(dt.attr("tg")+"Node").attr("stroke", "#333333");
                      if (d3.select(dt.attr("tg")+"Arrow")){ 
                        d3.select(dt.attr("tg")+"Arrow").attr("fill", "#333333");
                        };
                    };

                      dt.attr("stroke", col);
                  };
          };

    function normal(dt){
            //dt=d3.select(this);

             var gradient1=dt.attr("C1");

              if (dt.attr("class")==="link"||dt.attr("class")==="loop"|| dt.attr("class")==="loss"){
                var solids=solids=d3.select(dt.attr("sc")+"Node").attr("C1");

                      d3.select(dt.attr("sc")).attr("fill", "#333333");
                      d3.select(dt.attr("sc")+"Node").attr("fill", solids);
                      d3.select(dt.attr("sc")+"Node").attr("stroke", solids);
                      if (d3.select(dt.attr("sc")+"Arrow")){ 
                        d3.select(dt.attr("sc")+"Arrow").attr("fill", solids);
                        };
              };
              if (dt.attr("class")==="link"||dt.attr("class")==="loop"|| dt.attr("class")==="adding"){
                  var solidt=d3.select(dt.attr("tg")+"Node").attr("C1");

                      d3.select(dt.attr("tg")).attr("fill", "#333333");
                      d3.select(dt.attr("tg")+"Node").attr("fill", solidt);
                      d3.select(dt.attr("tg")+"Node").attr("stroke", solidt);
                      if (d3.select(dt.attr("tg")+"Arrow")){ 
                        d3.select(dt.attr("tg")+"Arrow").attr("fill", solidt);
                        };
              };
                      dt.attr("stroke", gradient1);
                      
          };

// highlights mouseover/mouse-out for the NODES AND THEIR LINKS (SOURCE/TARGET)--------------------------------------------------------------------------------
    // similar highlights to above
    //  should there be a pop-up label? for a placeholder rectangle below node (subtitle to be decided, triggered?) - go above/below as opposed to label trigger
    function highlightN(dt){
            //dt=d3.select(this);
            //NodeOver and NodeIcon for the bracket interactions to be more general.
            var nodeOrigin='';
            if (dt.attr("id").match("NodeOver")){ nodeOrigin = "#"+dt.attr("id").replace("NodeOver", ''); 
            } else if (dt.attr("id").match("NodeIcon")){ nodeOrigin = "#"+dt.attr("id").replace("NodeIcon", ''); 
            } else { nodeOrigin = "#"+dt.attr("id").replace("Node", ''); };
            console.log(nodeOrigin);
            var highLink=[], // to hold all source links // target links
                highNodes=[]; // the nodes at the end of those links

            var mainNode=graph.nodes.filter(function(d){
                  return d.name===nodeOrigin.slice(1);
                });
                
                mainNode[0].sourceLinks.forEach(function(source){
                  highLink.push("#"+source.source.name+source.target.name);
                  if (source.target !== -1){ 
                      highNodes.push("#"+source.target.name+"Node"); 
                      //highLink.push(source.source.name+source.target.name); 
                    };
                });
                mainNode[0].targetLinks.forEach(function(target){
                  highLink.push("#"+target.source.name+target.target.name);
                  if (target.source !== -1){ highNodes.push("#"+target.source.name+"Node"); };
                }); 

                graph.loop.forEach(function(loop){
                  if (loop.name === nodeOrigin.slice(1)){
                    highLink.push("#"+loop.name+loop.nameEnd);
                    highNodes.push("#"+loop.nameEnd+"Node"); 
                  } else if (loop.nameEnd === nodeOrigin.slice(1)){
                    highLink.push("#"+loop.name+loop.nameEnd);
                    highNodes.push("#"+loop.name+"Node");
                  };
                });

            var col="";
            var colA="";
            var colL="";
            if (opt.c==="greysContrast"|| opt.c==="defaultColor"|| opt.c==="googleFonts"){
                col="#ff006a";
                colA="url(#gradHA)";
                colL="url(#gradLA)";
            } else if (opt.c==="colorGradients"){
                col="#333333";
                colA="url(#gradHAG)";
                colL="url(#gradLAG)";
            };
            

                // original node filling
                      d3.select(nodeOrigin+"Node").attr("fill", col);
                      d3.select(nodeOrigin+"Node").attr("stroke", col);
                      d3.select(nodeOrigin).attr("fill", col);
                        if (d3.select(nodeOrigin+"Arrow")){ 
                        d3.select(nodeOrigin+"Arrow").attr("fill", col);
                        };

                // loop throught additional nodes
                //console.log(nodeOrigin, highLink, highNodes);
                highLink.forEach(function(link){
                  if (d3.selectAll(link).attr("class")==="link"||d3.selectAll(link).attr("class")==="loop"){ 
                    d3.selectAll(link).attr("stroke", col);
                  } else if (d3.selectAll(link).attr("class")==="adding"){
                    d3.selectAll(link).attr("stroke",colA);
                  } else if (d3.selectAll(link).attr("class")==="loss"){
                    d3.selectAll(link).attr("stroke",colL);
                  };
                });

                highNodes.forEach(function(node){
                    d3.selectAll(node).attr("fill", col);
                    d3.selectAll(node).attr("stroke", col);
                    var nodetext=node.slice(0,-4);
                      d3.select(nodetext).attr("fill", col);
                    if (d3.select(node+"Arrow")){ 
                        d3.select(node+"Arrow").attr("fill", col);
                        };
                });
          };

    function normalN(dt){
            //dt=d3.select(this);

            // will have to collect original colors for each type... all will be different
            var nodeOrigin='';
            if (dt.attr("id").match("NodeOver")){ nodeOrigin = "#"+dt.attr("id").replace("NodeOver", ''); 
            } else if (dt.attr("id").match("NodeIcon")){ nodeOrigin = "#"+dt.attr("id").replace("NodeIcon", ''); 
            } else { nodeOrigin = "#"+dt.attr("id").replace("Node", ''); };
            console.log(nodeOrigin);

            var highLink=[], // to hold all source links // target links
                highNodes=[];

            //var col=dt.attr("C1"); // will have to collect original colors for each type... all will be different
                //colLink=[],
                //colNodes=[];

            var mainNode=graph.nodes.filter(function(d){
                  return d.name===nodeOrigin.slice(1);
                });
                
                mainNode[0].sourceLinks.forEach(function(source){
                  highLink.push("#"+source.source.name+source.target.name);
                  if (source.target !== -1){ 
                      highNodes.push("#"+source.target.name+"Node"); 
                      //highLink.push(source.source.name+source.target.name); 
                    };
                });
                mainNode[0].targetLinks.forEach(function(target){
                  highLink.push("#"+target.source.name+target.target.name);
                  if (target.source !== -1){ highNodes.push("#"+target.source.name+"Node"); };
                }); 

                graph.loop.forEach(function(loop){
                  if (loop.name === nodeOrigin.slice(1)){
                    highLink.push("#"+loop.name+loop.nameEnd);
                    highNodes.push("#"+loop.nameEnd+"Node"); 
                  } else if (loop.nameEnd === nodeOrigin.slice(1)){
                    highLink.push("#"+loop.name+loop.nameEnd);
                    highNodes.push("#"+loop.name+"Node");
                  };
                });
                //console.log(graph.loop);
                console.log(nodeOrigin, highLink, highNodes);


                // original node filling
                var colN=d3.select(nodeOrigin+"Node").attr("C1");
                      d3.select(nodeOrigin+"Node").attr("fill", colN);
                      d3.select(nodeOrigin+"Node").attr("stroke", colN);
                      d3.select(nodeOrigin).attr("fill", "#333333");
                        if (d3.select(nodeOrigin+"Arrow")){ 
                        d3.select(nodeOrigin+"Arrow").attr("fill", colN);
                        };

                // links
                highLink.forEach(function(link){
                  col=d3.select(link).attr("C1");
                  d3.selectAll(link).attr("stroke", col);
                });

                // nodes
                highNodes.forEach(function(node){
                    //console.log(node);
                    col=d3.select(node).attr("C1");
                    d3.selectAll(node).attr("fill", col);
                    d3.selectAll(node).attr("stroke", col);
                    var nodetext=node.slice(0,-4);
                      d3.select(nodetext).attr("fill", "#333333");
                    if (d3.select(node+"Arrow")){ 
                        d3.select(node+"Arrow").attr("fill", col);
                        };
                });



              /*if (dt.attr("class")==="link"||dt.attr("class")==="loop"|| dt.attr("class")==="loss"){
                var solids=solids=d3.select(dt.attr("sc")+"Node").attr("C1");

                      d3.select(dt.attr("sc")).attr("fill", "#333333");
                      d3.select(dt.attr("sc")+"Node").attr("fill", solids);
                      d3.select(dt.attr("sc")+"Node").attr("stroke", solids);
                      if (d3.select(dt.attr("sc")+"Arrow")){ 
                        d3.select(dt.attr("sc")+"Arrow").attr("fill", solids);
                        };
              };
              if (dt.attr("class")==="link"||dt.attr("class")==="loop"|| dt.attr("class")==="adding"){
                  var solidt=d3.select(dt.attr("tg")+"Node").attr("C1");

                      d3.select(dt.attr("tg")).attr("fill", "#333333");
                      d3.select(dt.attr("tg")+"Node").attr("fill", solidt);
                      d3.select(dt.attr("tg")+"Node").attr("stroke", solidt);
                      if (d3.select(dt.attr("tg")+"Arrow")){ 
                        d3.select(dt.attr("tg")+"Arrow").attr("fill", solidt);
                        };
              };
                      dt.attr("fill", gradient1);*/
                      
          };

// 

// add in the links
  var link = grouplines.selectAll(".link")
      .data(graph.links)
    .enter().append("path")
      .attr("class", "link")
      .attr("d", path)
      .attr("id", function(d){ return d.source.name+d.target.name; })
      .attr("sc", function(d){ return "#"+d.source.name;})
      .attr("tg", function(d){ return "#"+d.target.name;})
      .attr("C1", function(d, i){
              return "url(#grad"+i+")";})
      .style("stroke-width", function(d) { return Math.max(1, d.dy); })
      .attr("stroke", function(d, i){
              return "url(#grad"+i+")";}) 
      .on("mouseover", function(d) {
        var b=(d3.select(this));
        highlight(b);
      })
      .on("mouseout", function(d){
        var b=(d3.select(this));
        normal(b);
      })
      .sort(function(a, b) { return b.dy - a.dy; });

// add the link titles
  link.append("title")
        .text(function(d) {
    		return d.source.name + " → " + 
                d.target.name + "\n" + format(d.value); });

var adding = grouplines2.selectAll(".adding")
      .data(graph.adding)
    .enter().append("path")
      .attr("class", "adding")
      .attr("id", function(d){ return d.source.name+d.target.name; })
      .attr("tg", function(d){ return "#"+d.target.name;})
      .attr("d", function(d){
        return d.path;})
      .attr("C1", function(d, i){
              return "url(#gradA"+i+")";})
      .attr("stroke-width", function(d) { 
             return Math.max(1, d.stroke); })
      .attr("stroke", function(d, i){
              return "url(#gradA"+i+")";})
      .on("mouseover", function(d) {
        var b=(d3.select(this));
        highlight(b);
      })
      .on("mouseout", function(d){
        var b=(d3.select(this));
        normal(b);
      });
              //return d.scolor;})
      //.sort(function(a, b) { return b.dy - a.dy; });
  adding.append("title")
        .text(function(d) {
        return d.name + " → " + 
                d.target.name + "\n" + format(d.value) + " added"; });


var loss = grouplines2.selectAll(".loss")
      .data(graph.loss)
    .enter().append("path")
      .attr("class", "loss")
      .attr("id", function(d){ return d.source.name+d.target.name; })
      .attr("sc", function(d){ return "#"+d.source.name;})
      .attr("d", function(d){
        return d.path;})
      .attr("C1", function(d, i){
              return "url(#gradL"+i+")";})
      .attr("stroke-width", function(d) { 
             return Math.max(1, d.stroke); })
      .attr("stroke", function(d, i){
              return "url(#gradL"+i+")";})
      .on("mouseover", function(d) {
        var b=(d3.select(this));
        highlight(b);
      })
      .on("mouseout", function(d){
        var b=(d3.select(this));
        normal(b);
      });
              //return d.scolor;})
      //.sort(function(a, b) { return b.dy - a.dy; });

  loss.append("title")
        .text(function(d) {
        return d.source.name + " → " + 
                d.name + "\n" + format(d.value) + " lost"; });



var loop = grouplines2.selectAll(".loop")
      .data(graph.loop)
    .enter().append("path")
      .attr("class", "loop")
      .attr("d", function(d){
        return d.path;})
      .attr("id", function(d){ return d.name+d.nameEnd; })
      .attr("sc", function(d){ return "#"+graph.nodes[d.source].name;})
      .attr("tg", function(d){ return "#"+graph.nodes[d.target].name;})
      .attr("C1", function(d, i){
              return "url(#gradF"+i+")";})
      .attr("stroke-dasharray", [5,1])
      .style("stroke-width", function(d) { 
             return Math.max(1, d.stroke); })
      .attr("stroke", function(d, i){
              return "url(#gradF"+i+")";})
      .on("mouseover", function(d) { // need to standardize/rebuilt to finish this!
        var b=(d3.select(this));
        highlight(b);
      })
      .on("mouseout", function(d){
        var b=(d3.select(this));
        normal(b);
      }) ;

  loop.append("title")
        .text(function(d) {
        return d.name + " → " + 
                d.nameEnd + "\n" + format(d.value) + " in feedback"; });


// add in the nodes
  var node = groupnodes.selectAll(".node")
      .data(graph.nodes)
    .enter().append("g")
      .attr("class", "node")      
      .attr("transform", function(d) { 
		    return "translate(" + d.x + "," + d.y + ")"; })
    .call(d3.behavior.drag()
      .origin(function(d) { return d; })
      .on("dragstart", function() { 
		      this.parentNode.appendChild(this); })
      .on("drag", dragmove));

      var triFunction = d3.svg.line()
                        .x(function(d) { return d.x; })
                         .y(function(d) { return d.y; })
                         .interpolate("linear");



    graph.nodes.forEach(function(d){ // the coordinates for all arrow systems
        var lineData=[{"x":d.dx, "y":-5}, {"x":d.dx+5, "y":-5}, {"x":.33*d.dy+d.dx+5, "y":d.dy/2}, {"x":d.dx+5, "y":d.dy+5}, {"x":d.dx, "y":d.dy+5}, {"x":d.dx, "y":0}];
        var lineData0=[{"x":d.dx+5, "y":-5}, {"x":.33*d.dy+d.dx+5, "y":d.dy/2}, {"x":d.dx+5, "y":d.dy+5}]; //excess arrows white line

        //var lineData1=[{"x":5, "y":0}, {"x":d.dx/4*3, "y":0}, {"x":d.dx, "y":d.dy/2}, {"x":d.dx/4*3, "y":d.dy}, {"x":5, "y":d.dy}, {"x":d.dx/2, "y":d.dy/2}, {"x":5, "y":0}]; //embedded arrow white out
       var lineData1=[{"x":d.dx/2, "y":0}, {"x":d.dx/8*7, "y":0}, {"x":d.dx, "y":d.dy/2}, {"x":d.dx/8*7, "y":d.dy}, {"x":d.dx/2, "y":d.dy}, {"x":d.dx/8*5, "y":d.dy/2}, {"x":d.dx/2, "y":0}]; //embedded arrow white out

        var lineData2=[{"x":5, "y":5}, {"x":d.dx-5, "y":5}, {"x":d.dx-5, "y":d.dy-5}, {"x":5, "y":d.dy-5}];
        var lineData2a=[{"x":(5+d.dx/10), "y":0}, {"x":(d.dx-5-d.dx/10), "y":0}, {"x":(d.dx-5-d.dx/10), "y":d.dy}, {"x":(5+d.dx/10), "y":d.dy}];


        //console.log(lineData);
        d.arrow=triFunction(lineData);
        d.arrow0=triFunction(lineData0);
        d.arrow1=triFunction(lineData1);
        d.arrow2=triFunction(lineData2);
        d.arrow2a=triFunction(lineData2a);
      });

      //console.log(graph.nodes);
      //console.log(width+margin.right*2);

  //-------------------------------adding the different articulations/arrows----------------------------------------------    

  // add the rectangles for the nodes (white plus transparency)
    node.append("rect")
      .attr("height", function(d) { return d.dy; })
      .attr("width", sankey.nodeWidth())
      .attr("opacity", 1)
      .style("fill", "#ffffff");

  node.append("rect")
      .attr("height", function(d) { return d.dy; })
      .attr("width", sankey.nodeWidth())
      .attr("C1", function(d) { 
      return d.color = color(d.name.replace(/ .*/, "")); })
      .attr("id", function(d){ return d.name+"Node";})
      .attr("opacity", .9)
      .attr("fill", function(d) { 
      return d.color = color(d.name.replace(/ .*/, "")); })
      .attr("stroke", function(d) { 
      return d.color = color(d.name.replace(/ .*/, "")); })
      .attr("stroke-width", .25)
      .on("mouseover", function(d) {
        var b=(d3.select(this));
        highlightN(b);
      })
      .on("mouseout", function(d){
        var b=(d3.select(this));
        normalN(b);
      })


    .append("title")// correct this later...
      .text(function(d) { 
      return d.name + "\n" + format(d.value); });

      //------------------------------- arrow and overlay options-----------------------------------------------------------

        if (opt.n==="bracketIcons"){

           node.append("path") //trianglar mask on node
                  .attr("d", function(d){
                      return d.arrow2;
                  })
                  .style("fill", "#ffffff")
                  .attr("opacity", 1);

          node.append("path") //trianglar mask on node
                  .attr("d", function(d){
                      return d.arrow2a;
                  })
                  .style("fill", "#ffffff")
                  .style("stroke", "#ffffff")
                  .attr("id", function(d){ return d.name+"NodeOver";})
                  .attr("opacity", 1)
                  .attr("cursor", "move")
                  .on("mouseover", function(d) {
                      var b=(d3.select(this));
                      highlightN(b);
                    })
                    .on("mouseout", function(d){
                      var b=(d3.select(this));
                      normalN(b);
                    });

          node.append("image") //add pattern as def then d.val to url icon.
                  .attr("x", function(d){
                    return d.dx/2-14;
                  })
                  .attr("y", function(d){
                    return d.dy/2-14;
                  })
                  .attr("height", 28)
                  .attr("width", 28)
                  .attr("id", function(d){ return d.name+"NodeIcon";})
                  .attr("background", function(d) { 
                      return d.color = color(d.name.replace(/ .*/, "")); })
                  .attr("xlink:href", function(d){
                    return "img/"+d.icon;
                    }) // the question becomes how to provide/link to icons or let people make their own????... specifying by link is easy.... or really by node..
                  .attr("opacity", 1)
                  .attr("cursor", "move")
                  .on("mouseover", function(d) {
                      var b=(d3.select(this));
                      highlightN(b);
                    })
                    .on("mouseout", function(d){
                      var b=(d3.select(this));
                      normalN(b);
                    });

            // need something to pull and fill icons (svg series). . . 

        };

        if (opt.n==="expandedArrows" || opt.n==="background" ){

              node.append("path") //triangle basic for arrow (underlay)
                  .attr("d", function(d){
                      return d.arrow;
                  })
                  .attr("fill", "#ffffff")
                  .attr("opacity", 1);

              node.append("path") //triangle basic for arrow
                  .attr("d", function(d){
                      return d.arrow;
                  })
                  .attr("id", function(d){ console.log(d.name+"Arrow"); return d.name+"Arrow";})
                  .attr("fill", function(d) {
                  if ((width+margin.right*2)-d.x<200){
                      return "none";
                  } else {
                      return d.color = color(d.name.replace(/ .*/ , "")); }})
                  .attr("opacity", .9);

              node.append("path") //triangle edge for arrow
                  .attr("d", function(d){
                      return d.arrow0;
                  })
                  .attr("stroke", function(d){
                      if ((width+margin.right*2)-d.x<200){
                      return "none";
                  } else {
                    return "#ffffff";}})
                  .style("stroke-linecap", "round")
                  .attr("fill", "none")
                  .style("stroke-width", "5px"); 
        };

    


// change this to a set of options - rectangle, arrow/arrow impression sq, arrow extended, other

// add in the title for the nodes
  node.append("text") 
      .attr("x", function(d) { 
            if (opt.n==="bracketIcons"){
                return d.dx/2;
                } else {
                  return d.dx-5;
                };
                })
      .attr("y", -7)
      .attr("id", function(d) { return d.name; })
      .attr("dy", ".35em")
      .attr("text-anchor", function(d) { 
            if (opt.n==="bracketIcons"){
                return "middle";
                } else {
                  return "end";
                };
                })
      .attr("stroke", "none")
      .attr("transform", null)
      .attr("font-size", 10)
      .attr("font-family", function(d){
        if (opt.c!=="googleFonts"){
          return "TrendHMSans-One";
          } else {
            return gFont;
          };
          }) // set this to function with google fonts
      .text(function(d) { return d.name; })
      /*.on("mouseover", function(d) {
                    //Get this bar's x/y values, then augment for the tooltip
                    var xPosition = parseFloat(d3.select(this).attr("x"));
                    var yPosition = parseFloat(d3.select(this).attr("y")) + 10;
                    var id="#"+this.id;
                    console.log(id);
                    //Create the tooltip label
                    if (opt.n==="bracketIcons"|| opt.n==="defaultNodes"){

                            d3.select(id).append("rect")
                                 .attr("id", "tooltip")
                                 //.attr("x", xPosition-10)
                                 .attr("x", xPosition+22)
                                 .attr("y", yPosition)
                                 .attr("width", 150)
                                 .attr("height", 20)
                                 .attr("rx", 5)
                                 .attr("ry", 5)
                                 .attr("fill", "#ffffff")
                                 .attr("stroke-width", .5)
                                 .attr("stroke", "#e7e7e7")
                                 .attr("opacity", .9)
                                 .filter(function(d){ return d.x > width /8*7; })
                                 .attr ("x", function(d){return xPosition-d.dx-130});
                            // add in the subtitle for the nodes
                            d3.select(id).append("text") 
                                .attr("id", "subtitle")
                                .attr("x", xPosition+25)
                                .attr("y", yPosition+10)
                                .attr("dy", ".35em")
                                .attr("text-anchor", "start")
                                .attr("font-family", function(d){
                                  if (opt.c!=="googleFonts"){
                                    return "inherit";
                                    } else {
                                      return gFontp;
                                    };
                                    })
                                .attr("text-transform", "lowercase")
                                .attr("font-size", 12)// set this to function with google fonts
                                .text(function(d) { return "short subtitle to go here"; })
                                .filter(function(d){ return d.x > width /8*7; })
                                .attr ("x", function(d){return xPosition-d.dx-125});
                          } else {

                            // add background image fill of svg group...

                            d3.select(id).append("rect")
                                 .attr("id", "tooltip")
                                 .attr("x", xPosition-160)
                                 .attr("y", yPosition)
                                 .attr("width", 150)
                                 .attr("height", 20)
                                 .attr("rx", 5)
                                 .attr("ry", 5)
                                 .attr("fill", "#ffffff")
                                 .attr("stroke-width", .5)
                                 .attr("stroke", "#e7e7e7")
                                 .attr("opacity", .9)
                                 .filter(function(d){ return d.x > width /8*7; })
                                 .attr ("x", function(d){return xPosition-d.dx-130});

                          d3.select(id).append("text")
                                .attr("id", "subtitle") 
                                .attr("x", xPosition-150)
                                //.attr("x", xPosition-5)
                                .attr("y", yPosition+10)
                                .attr("dy", ".35em")
                                .attr("text-anchor", "start")
                                .attr("text-transform", "lowercase")
                                .attr("font-family", function(d){
                                  if (opt.c!=="googleFonts"){
                                    return "inherit";
                                    } else {
                                      return gFontp;
                                    };
                                    })
                                .attr("font-size", 12)// set this to function with google fonts
                                .text(function(d) { return "short subtitle to go here"; })
                                .filter(function(d){ return d.x > width /8*7; })
                                .attr ("x", function(d){return xPosition-d.dx-120});;
                          };
                          })

               .on("mouseout", function() { 
                    
                    d3.selectAll("#tooltip").remove();
                    d3.selectAll("#subtitle").remove();
                    
                   })*/
               .on("click", function(d) {

                      console.log(this.id);
                   });
    /*.filter(function(d) { return d.x < width /8; })
      .attr("x", 0) // set this to vary based on the arrow options...
      .attr("text-anchor", "start")
      .attr("stroke", "none");*/


// the function for moving the nodes in both the x and the y
  function dragmove(d) {
    d3.select(this).attr("transform", 
        "translate(" + (d.x = Math.max(0, Math.min(width - d.dx, d3.event.x))) + "," + (
                d.y = Math.max(0, Math.min(height - d.dy, d3.event.y))
            ) + ")");
    sankey.relayout();
    addingCurve();
    lossCurve();
    loopCurve();
    link.attr("d", path);
    adding.attr("d", function(d){
        return d.path;})
    loss.attr("d", function(d){
        return d.path;})
    loop.attr("d", function(d){
        return d.path;});
  }
});

</script>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="js/bootstrap.min.js"></script>

</body>
</html>
